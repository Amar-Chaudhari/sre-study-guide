- Kernel
  - The kernel is a computer program that manages I/O requests from software, and translates them into data processing instructions for the central processing unit and other electronic components of a computer.
  - The core part of Linux. It is responsible for all major activities of this operating system. It is consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs.
  - The critical code of the kernel is usually loaded into a protected area of memory, which prevents it from being overwritten by other, less frequently used parts of the operating system or by applications. The kernel performs its tasks, such as executing processes and handling interrupts, in kernel space, whereas everything a user normally does, such as writing text in a text editor or running programs in a GUI (graphical user interface), is done in user space.
  - Processes running in user space have normal privileges.
  - Processes running in kernel space have all privileges and can do anything.
  - Processes switch between user space and kernel space using system calls.
  - /etc/sysctl.conf contains kernel parameters that can be modified. You can also use the sysctl command to make changes at runtime.


- System Libraries
  - System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implements most of the functionalities of the operating system and do not requires kernel module's code access rights.

- Journaling
  - A journaling file system is a file system that keeps track of changes not yet committed to the file system's main part by recording the intentions of such changes in a data structure known as a "journal", which is usually a circular log.
  - After a crash, recovery simply involves reading the journal from the file system and replaying changes from this journal until the file system is consistent again. The changes are thus said to be atomic (not divisible) in that they either succeed (succeeded originally or are replayed completely during recovery), or are not replayed at all (are skipped because they had not yet been completely written to the journal before the crash occurred).

- File Systems
  - NTFS
    - Windows Compatible
    - 2TB File Size
    - 256TB Partition Size
    - Journaling
  - ext3
    - Standard Linux filesystem
    - 2TB File Size
    - 32TB Partition Size
    - Journaling
  - ext4
    - Best choice for new installations that don't need to be completely standard
    - 16TB File Size
    - 1EB Partition Size
    - Journaling
  - XFS
    - Best choice for a mix of stability and advanced journaling
    - 8EB File Size
    - 8EB Partition Size
    - Journaling with metadata

- inodes
    - In Unix file systems, files are indexed by an integer number, called the "i-number" or "inode number".
      - Print this with the -i option of ls
    - inodes do not contain file names, only other file metadata.
    - An inode is basically a pointer to a file.
    - A file's inode number stays the same when it is moved to another directory on the same device.
    - Files can have multiple names.
      - If multiple names hard link to the same inode then the names are equivalent.
      - This is unlike symbolic links, which depend on the original name, not the inode.
    - An inode may have no links.
      - An unlinked file is removed from disk, and its resources are freed for reallocation but deletion must wait until all processes that have opened it finish accessing it.
      - This includes executable files which are implicitly held open by the processes executing them.
    - POSIX dictates that regular files must have to following attributes:
      - Filesize in bytes
      - Device ID of the device containing the file
      - User ID of the file owner
      - Group ID of the file
      - File Mode which determines:
        - File type
        - Access permissions for owners, groups, and others.
      - System and user flags to protect the file by limiting its use and modification
      - Timestamps
        - ctime: inode change time
        - mtime: file content modification time
        - atime: Time the file was last accessed
      - Link count for how many hard links point to the inode.
      - Pointers to the disk blocks that store the file's contents (inode pointer structure)
    - Usually, the maximum number of inodes is fixed at file system creation, limiting the maximum number of files the file system can hold. A typical allocation is one percent of total size.
    - When you delete a file, what really happens is the inode is unlinked from the filename, but if some other program is using the file, it still has a link open to the OS, and will continue to be updated. A file is not really deleted until all links have been removed (even then, the data is still on the disk, but not indexed in anyway and thus very hard to recover). All of this means that you can delete executing programs while they're running without crashing and move files before they're finished downloading without corruption.
    - A directory is a list of names associated to inodes.  The directory contains an entry for:
      - Itself (.)
      - Its parent (..)
      - Each of its children (files or other directories inside the current working directory)
    - The file system driver must search a directory looking for a particular filename and then convert the filename to the correct corresponding inode number.
    - Installation of new libraries is simple with inode filesystems. A running process can access a library file while another process replaces that file, creating a new inode, and an all new mapping will exist for the new file so that subsequent attempts to access the library get the new version. This facility eliminates the need to reboot to replace currently mapped libraries.
      - For this reason, when updating programs, best practice is to delete the old executable first and create a new inode for the updated version, so that any processes executing the old version may proceed undisturbed.

- Client/Server Protocols

- System Calls
  - API between user space and kernel space.
  - How a program requests a service from the kernel.
  - Five major categories of system calls:
  	- Process Control
  	- File Management
  	- Device Management
  	- Information Maintenance
  	- Communication

- Signals
	- A limited form of inter-process communication.
	- An asynchronous notification sent to a process or a specific thread within the same process.
	- Examples:
		- CTRL+C (SIGINT, Interrupt): Terminate.
		- CTRL+Z (SIGTSTP): Suspend execution.
		- CTRL+\ (SIGQUIT): Terminate and dump core.
		- CTRL+T (SIGINFO): Show information about the running command.

- Application Tracing
	- strace command
		- strace -p <PID> -s <stringSize> -o <outputFile>

- Memory Management
  - Linux is a virtual memory system; the addresses seen by user programs do not directly correspond to physical addresses used by the hardware.
  - Programs running on the system can allocate more memory than is physically available, such as mapping the program's memory to device memory.
  - malloc()
    - Library function implemented in the standard C library and is not a system call.
    - Memory allocated is not initialized.
      - free() frees the memory space pointed to by a previous call to malloc(), calloc(), or realloc().
    - Memory is obtained from the brk()/sbrk() system call, or anonymous memory via mmap().
  - The kernel allocates a virtual memory area for the application but does not allocate physical memory.
