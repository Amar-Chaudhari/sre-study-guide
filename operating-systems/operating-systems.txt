- Processes
  - A process is an executing program
  - Made up of:
    - Program Code
    - Machine Registers
    - Global Data
    - Stack
    - Open Files (File Descriptors)
    - An Environmnet (Environment Variables, Security Credentials)
      - Key=Value Pairs
    - Context Information
      - Process ID (PID)
        - Positive integer that uniquely identifies a running process
        - Stored in a variable of type pid_t
      - Parent Process ID (PPID)
      - Real User ID
        - ID of the user or process which started this process.
      - Effective User ID
        - ID of the user who wrote the process' program
      - Current Directory
      - File Descriptor Table
      - Environment
      - Pointer to Program Code
      - Pointer to Data
        - Memory for global variables
      - Pointer to Stack
        - Memory for local variables
      - Pointer to Heap
        - Dynamically allocated
      - Execution Priority
      - Signal Information
  - Important File System Processes
    - init
      - Started at boot time
      - Responsible for starting other processes
      - Uses file inittab & directories /etc/rc?.d
    - getty
      - Login process that manages login sessions
  - Process Methods:
    - exec()
      - Initiates a new program in the same environment in which it is operating.
      - The parent process never regains control unless there is an exec() error.
    - fork()
      - Creates a child process by making an exact duplicate of the parent process.
      - Both parent and child continue running.
    - getenv()
      - Searches the environment variable list for a string that matches the string requested.
      - Returns a pointer to the value in the environment or null if there is no match.
    - getpid()
      - Get Process ID (PID)
    - getppid()
      - Get Parent Process ID (PPID)
    - putenv()
      - Adds or changes the value of environment variables.
      - Takes arguments in the form of key=value string.
      - If the key doesn't exist in the environment then the string is added to the environment.
      - If the key does exist then the value in the environment is overwritten.
      - Returns 0 on success or -1 on error.
    - wait()
      - Suspends calling process until child has finished.
      - Returns the PID of the terminated child if OK, -1 if error.
    - waitpid()
      - Can wait for a particular child.
  - Since a child process is a copy of the parent, is has copies of the parent's data.
    - A change to a variable in the child will not change that variable in the parent.
  - Zombie Processes
    - A child process becomes a zombie process if the child exits when the parent isn't currently executing wait()
    - Status data about the child is stored until the parent does a wait()
    - The reason the process is a zombie is because it is "dead" but hasn't yet been "reaped" by the parent process.
  - If a parent exits when 1 or more children are still running, the children are adopted by /etc/init, which can then monitor or kill them.

- Threads
  - The kernel sees no distiction between process and threads; everything is simply a runnable task.
    - Each process has a separate stack, text, data, and heap.
    - Threads have their own stack, but share text, data, and heap with the process.
  - Threads are called "Light Weight Processes" (LWP) at kernel level, and threads at user level.
  - When a thread is created, it's assigned a Thread ID.
    - Unlike a PID (which is unique across the system), a thread ID is unique only in the context of a single process.
    - Thread IDs are not necessarily integers; they could be structures.
    - Not easy to print, like a PID.
  - Two interfaces to create threads:
    - clone()
      - Low level system call.
    - pthread_create()
      - Higher level interface.
  - Linux threading is 1:1 (not 1:N or M:N).

- Concurrency Issues
  - Race Conditions
    - Happens when multiple instances interleave processes instead of running them in the as-expected sequence.
    - Critical Region:
      - Piece of code containing the concurrency issue.
    - Solution:
      - Recognize when simultaneous accesses occur.
      - Use locks to make sure only one instance can enter the critical region at any time.

- Locks
  - Two main types of kernel locks:
    - Spinlocks
      - If you cant get the spinlock, you keep trying (spinning) until you can.
      - Small, fast, can be used anywhere.
      - Best used for critical sections of code that are fast to complete.
      - It's imperative to not have any section of code inside a spinlock attempt to acquire a lock twice.  This results in a deadlock.
    - Semaphores
      - Simple counters that indicate the status of a resource.
        - if(counter > 0) then the resource is available.
        - if(counter <= 0) then the resource is unavailable (busy or being used by another process).
      - Can be either binary or counting, depending on the number of shared resources.
        - Binary (0 or 1, locked or unlocked) if a single shared resource is used.
        - Counting if the number of resources shared across users is greater than one.
      - Different from spinlocks because the task sleeps rather than busily waits (spins) while attempting to obtain the locked resource.
      - A process holding a semaphor is safe to block.
      - Can have more than one holder at a time (number decided at initialization)
      - Most commonly used as a single-holder lock (mutex).
      - If you can't get a semaphore, your task will put itself on the queue and be woken up when the semaphore is released.
        - The CPU will do something else while you're waiting, but in cases where you can't sleep, you have to use a spinlock instead.
      - Better for code sections that take more time to complete that sections where you'd use a spinlock.
    - Mutexes (Mutual Exclusions)
      - A semaphore with a count of 1.
      - Have the concept of an owner; only the process that locked the mutex is supposed to be able to unlock it.
      - May provide priority inversion safety.
        - If the mutex knows its current owner, it is possible to promote the priority of the owner whenever a higher priority task starts waiting on the mutex.
      - May provide deletion safety, where the process holding the mutex cannot be accidentally deleted.

- Monitors
  - Sychronzation construct that allows threads to have both mutual exclusion and the ability to wait (block) for a certain condition to become true.
  - Typically consts of a mutex (lock) and condition variables.
    - A condition variable is basically a container of threads that are waiting on a certain condition.
  - Provide a mechanism for threads to temporarily give up exclusive access in order to wait for some condition to be met, before regaining exclusive access and resuming their task.

- Deadlocks vs. Livelocks
  - Deadlocks
    - Condition when two or more processes are waiting for another to release a resource, or more than two process are waiting for resources in a circular chain.
    - Conditions necessary for a deadlock to occur (all conditions must be true for a deadlock to occur (The Coffman Conditions)):
      - Mutual Exclusion
        - A resource cannot be used by more than one process at a time.
        - Prevention:
          - Ensure no process may have exclusive access to a resource (non-blocking synchronization algorithms).
      - Hold & Wait
        - Processes already holding resources may request new resources.
        - Prevention:
          - Require processes to request all the resources they need before starting.
          - Require processes to release all resources before requesting all resources they will need (Serializing Tokens, All-Or-None algorithms).
      - No Preemption
        - Only a process holding a resource may release it.
        - Prevention:
          - Inability to enforce preemption may interfere with a priority algorithm.
          - Lock-free & wait-free algorithms.
      - Circular Wait
        - Two or more processes form a circular chain where each process waits for a resource that the next process in the chain holds.
        - Prevention:
          - Disable interrupts during critical sections.
          - Use a heirarchy to determine a partial ordering of resources.
  - Livelocks
    - Special case of resource starvation:
      - The processes involved constantly change with regard to one another.
    - Analogous to two people trying to pass each other in a narrow hallway, both trying to step out of the others way, but both going in the same direction.
    - A risk with some algorithms that try to detect and recover from deadlocks; if more than one process takes action, the deadlock detection algorithms can trigger repeatedly.
      - Can be avoided by ensuring that only one process (chose randomly or by priority) takes the recovery action.
